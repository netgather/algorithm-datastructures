概念：
    路径：
    图中的一条路径是一个顶点序列w(1),w(2),...,w(n)使得（w(i),w(i+1)）∈E且1≤i＜n。
    简单路径：一条简单路径是这样一条路径，其上的所有顶点都是互异的，但第一个顶点和最后一个顶点可能相同
    路径的长：该路径上边的个数，它等于n-1

    环：
    从一个顶点到它自身可以看成是一条路径，如果路径不包含边，那么路径的长为0
    从一个顶点到它自身可以看成是一条路径，如果该路径包含边，那么这条路径被称为环。环属于圈的一种。

    圈：
    有向图中的圈：满足w(1)=w(n)且长至少为1的一条路径；如果该路径是简单路径，那么这个圈就是简单圈
		   如果一个有向图没有圈，则称其为无圈的，一个有向无圈图简称为DAG
    无向图中的圈：除了满足有向图中圈的定义之外，我们还要求边是互异的，该要求的根据在于无向图中的路径
		   u,v,u不应该被认为是圈，因为(u,v)和(v,u)是同一条边

    连通图：
    如果在一个无向图中，从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的；
    具有这样性质的有向图称为强连通的。
    如果一个有向图不是强连通的，但将这个有向图变成无向图时，该无向图是连通的，那么称这个有向图是弱连通的
    完全图：每一对顶点间都存在一条边的图


图的搜索：
    图的搜索指的是系统化地跟随图中的边来访问图中的每个节点，图搜索算法可以用来发现图的结构。
    许多的图算法在一开始都会先通过搜索来获得图的结构，其他的一些算法则是对基本的搜索加以优化。
    图的搜索技巧是整个图算法领域的核心。

图的表示：
    图的两种最常见的计算机表示：邻接链表、邻接矩阵。
    邻接链表因为在表示稀疏图时非常紧凑而成为通常的选择。
    虽然邻接链表表示法和邻接矩阵表示法在渐进意义下至少是一样有效的，但是邻接矩阵表示法更为简单，
    因此在图规模比较小时，我们可能更倾向于使用邻接矩阵表示。而且，对于无向图来说，邻接矩阵还与一个优势：
    每个记录项只需要1位的存储空间。

图中属性的表示：
  对图进行操作的多数算法需要维持图中节点的属性或图中边的属性，这些属性可以使用通常的表述法进行表示，如v.d表示节点v的属性d;
  (u,v).f表示边(u,v)的f属性。这种方法只是用来表示和理解算法。在算法的实际程序里面实现节点和边属性则需要考虑很多方面，
  如：使用的程序设计语言、需要实现的算法、程序中使用图的方式等等。通常来讲，如果使用邻接链表来表示图，一种可行的方法是
  使用额外的数组来表示节点的属性，如一个与A数组相对应的数组d[1,...,|V|](如果与u邻接的节点都在A[u]中，则属性u.d将存放在数组项d[u]里)


赋权图：与每条边(u,v)相联系的是穿越该弧的代价(或称为值)
赋权路径长：一条路径u(i),u(j),...,u(n)每条边上的代价和
无权路径长：路径上的边数
单源最短路径问题：
    给定一个赋权图G=(V,E)和一个特定顶点s作为输入，找出从s到G中每一个其他顶点的最短赋权路径。
    一般来说，当不指明我们讨论的是赋权路径还是无权路径时，如果图是赋权的，那么路径就是赋权的。
  负边可能产生的问题：例如u(5)到u(4)的值为1，假设有负边的存在，则通过下面的循环u(5),u(4),u(2),u(5),u(4),
                  存在一条更短的路径，其值为-5，但是这条路径仍然不是最短的，因为我们可以在循环中滞留任意长的时间。
                  这个循环叫作负值圈。当负值圈出现在图中时，最短路径问题就是不确定的。
约定：在没有负值圈时，从u到u的最短路径为0

当前还不存在找出从s到一个顶点的路径比找出从s到所有顶点路径更快的算法。也就是说，假设需要找出从u到v的最短路径，
我们只能先找出从u到v的所有路径，然后从这些路径中选择一条最短的路径。

广度优先搜索：距离开始顶点最近的那些顶点首先被求值，而最远的那些顶点最后被求值。
           广度优先搜索按层处理顶点，这很像树的层序遍历。
广度优先搜索的结果可能依赖于对每个节点的邻接节点的访问顺序，广度优先搜索树可能不一样，但是每个节点的距离都是一样的，
与搜索顺序无关


最小生成树
给定一个无向赋权图G=(V,E)，我们希望找到一个无环子集T∈E，既能将所有的节点连接起来，又具有最小的权值。
由于T是无环的，并且连接所有的节点，因此，T必然是一棵树。我们称T是图G=(V,E)的最小生成树。
我们称求取该最小生成树的问题为最小生成树问题。最小生成树不是唯一的。
解决最小生成树的两种算法：Kruskal算法和Prim算法。这两种最小生成树算法都是贪心算法。
贪心算法的每一步必须在多个可能的选择中选择一种，贪心算法推荐选择在当前看来最好的选择。
贪心算法一般并不能保证找到一个全局最优的解决方案。但是，对于最小生成树问题来说，我们可以证明，
某些贪心策略确实能够找到一棵权重最小的生成树




